{"version":3,"sources":["proxy-polyfill.js","is-object.js","index.js","implementation.js"],"names":["isObject","o","_typeof","Symbol","iterator","obj","constructor","Implementation","lastRevokeFn","Proxy","target","handler","TypeError","throwRevoked","trap","unsafeHandler","get","set","apply","construct","k","bind","proxy","this","isMethod","targetIsFunction","usingNew","call","arguments","all","Array","prototype","slice","unshift","F","getter","prop","setter","value","propertyNames","Object","getOwnPropertyNames","propertyMap","forEach","real","getOwnPropertyDescriptor","desc","enumerable","defineProperty","prototypeOk","setPrototypeOf","getPrototypeOf","__proto__","_k","seal","revocable","p","revoke","exports","module","define","amd","window"],"mappings":"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","file":"proxy-polyfill.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n/**\n * @param {*} o\n * @return {boolean} whether this is probably a (non-null) Object\n */\nfunction isObject(o) {\n  return o ? (typeof o === 'undefined' ? 'undefined' : _typeof(o)) == 'object' || typeof o == 'function' : false;\n}\n\nvar Implementation = function () {\n  var lastRevokeFn = null;\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  var Proxy = function Proxy(target, handler) {\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    var throwRevoked = function throwRevoked() {};\n    lastRevokeFn = function lastRevokeFn() {\n      throwRevoked = function throwRevoked(trap) {\n        throw new TypeError('Cannot perform \\'' + trap + '\\' on a proxy that has been revoked');\n      };\n    };\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    var unsafeHandler = handler;\n    handler = { 'get': null, 'set': null, 'apply': null, 'construct': null };\n    for (var k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError('Proxy polyfill does not support trap \\'' + k + '\\'');\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler == 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as this, or a Function (if either it's callable, or apply is set).\n    // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n    var proxy = this;\n    var isMethod = false;\n    var targetIsFunction = typeof target == 'function';\n    if (handler.apply || handler.construct || targetIsFunction) {\n      proxy = function Proxy() {\n        var usingNew = this && this.constructor === proxy;\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        if (usingNew && handler.construct) {\n          return handler.construct.call(this, target, arguments);\n        } else if (!usingNew && handler.apply) {\n          return handler.apply(target, this, arguments);\n        } else if (targetIsFunction) {\n          // since the target was a function, fallback to calling it directly.\n          if (usingNew) {\n            // inspired by answers to https://stackoverflow.com/q/1606797\n            var all = Array.prototype.slice.call(arguments);\n            all.unshift(target); // pass class as first arg to constructor, although irrelevant\n            // nb. cast to convince Closure compiler that this is a constructor\n            var F = /** @type {!Function} */target.bind.apply(target, all);\n            return new F();\n          }\n          return target.apply(this, arguments);\n        }\n        throw new TypeError(usingNew ? 'not a constructor' : 'not a function');\n      };\n      isMethod = true;\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    var getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    var setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      var status = handler.set(this, prop, value, proxy);\n      if (!status) {\n        // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n        // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n        // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    var propertyNames = Object.getOwnPropertyNames(target);\n    var propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if (isMethod && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      var real = Object.getOwnPropertyDescriptor(target, prop);\n      var desc = {\n        enumerable: !!real.enumerable,\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    var prototypeOk = true;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));\n    } else if (proxy.__proto__) {\n      proxy.__proto__ = target.__proto__;\n    } else {\n      prototypeOk = false;\n    }\n    if (handler.get || !prototypeOk) {\n      for (var _k in target) {\n        if (propertyMap[_k]) {\n          continue;\n        }\n        Object.defineProperty(proxy, _k, { get: getter.bind(target, _k) });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    Object.seal(target);\n    Object.seal(proxy);\n\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n\n  Proxy.revocable = function (target, handler) {\n    var p = new Proxy(target, handler);\n    return { 'proxy': p, 'revoke': lastRevokeFn };\n  };\n\n  return Proxy;\n}();\n\nif ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n  module.exports = Proxy || Implementation;\n} else if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n  define(function () {\n    return Proxy || Implementation;\n  });\n} else if (window && !window.Proxy) {\n  window.Proxy = Implementation;\n}","/**\n * @param {*} o\n * @return {boolean} whether this is probably a (non-null) Object\n */\nexport default function isObject(o) {\n  return o ? (typeof o == 'object' || typeof o == 'function') : false;\n}\n","import Implementation from './implementation';\n\nif (typeof exports === 'object') {\n  module.exports = Proxy || Implementation;\n} else if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n  define(function() { return Proxy || Implementation; });\n} else if (window && !window.Proxy) {\n  window.Proxy = Implementation;\n}\n","import isObject from './is-object';\n\nexport default (function() {\n  let lastRevokeFn = null;\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  const Proxy = function(target, handler) {\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    let throwRevoked = function() {};\n    lastRevokeFn = function() {\n      throwRevoked = function(trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    let unsafeHandler = handler;\n    handler = {'get': null, 'set': null, 'apply': null, 'construct': null};\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler == 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as this, or a Function (if either it's callable, or apply is set).\n    // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n    let proxy = this;\n    let isMethod = false;\n    let targetIsFunction = typeof target == 'function';\n    if (handler.apply || handler.construct || targetIsFunction) {\n      proxy = function Proxy() {\n        let usingNew = (this && this.constructor === proxy);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        if (usingNew && handler.construct) {\n          return handler.construct.call(this, target, arguments);\n        } else if (!usingNew && handler.apply) {\n          return handler.apply(target, this, arguments);\n        } else if (targetIsFunction) {\n          // since the target was a function, fallback to calling it directly.\n          if (usingNew) {\n            // inspired by answers to https://stackoverflow.com/q/1606797\n            let all = Array.prototype.slice.call(arguments);\n            all.unshift(target);  // pass class as first arg to constructor, although irrelevant\n            // nb. cast to convince Closure compiler that this is a constructor\n            let F = /** @type {!Function} */ (target.bind.apply(target, all));\n            return new F();\n          }\n          return target.apply(this, arguments);\n        }\n        throw new TypeError(usingNew ? 'not a constructor' : 'not a function');\n      };\n      isMethod = true;\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    let getter = handler.get ? function(prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function(prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    let setter = handler.set ? function(prop, value) {\n      throwRevoked('set');\n      let status = handler.set(this, prop, value, proxy);\n      if (!status) {\n        // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n        // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n        // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      }\n    } : function(prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    let propertyNames = Object.getOwnPropertyNames(target);\n    let propertyMap = {};\n    propertyNames.forEach(function(prop) {\n      if (isMethod && prop in proxy) {\n        return;  // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      let real = Object.getOwnPropertyDescriptor(target, prop);\n      let desc = {\n        enumerable: !!real.enumerable,\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop),\n      };\n      Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    let prototypeOk = true;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));\n    } else if (proxy.__proto__) {\n      proxy.__proto__ = target.__proto__;\n    } else {\n      prototypeOk = false;\n    }\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n        Object.defineProperty(proxy, k, {get: getter.bind(target, k)});\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    Object.seal(target);\n    Object.seal(proxy);\n\n    return proxy;  // nb. if isMethod is true, proxy != this\n  };\n\n  Proxy.revocable = function(target, handler) {\n    let p = new Proxy(target, handler);\n    return {'proxy': p, 'revoke': lastRevokeFn};\n  };\n\n  return Proxy;\n})();\n"],"sourceRoot":"/source/"}